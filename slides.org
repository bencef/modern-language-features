#+OPTIONS: toc:nil num:nil ^:nil
#+TITLE: Modern language features
#+AUTHOR: Bence Fábián <begnoc@gmail.com>

* How we used to do programming

  Structured programming:

** Sequences

   #+BEGIN_SRC python
     a = foo()
     b = bar(a)
   #+END_SRC

** Branches

   #+BEGIN_SRC python
     if something():
         foo()
     else:
         bar()
   #+END_SRC

** Loops

   #+BEGIN_SRC python
     while something():
         foo()
   #+END_SRC

* Structured programming

  These can be combined to write most programs

  #+BEGIN_SRC python
    import math

    def get_max(numbers):
        max = -math.inf
        for number in numbers:
            if number > max:
                max = number
        return max
  #+END_SRC

* Structured programming

  =goto= statements still abound in large =C= codebases.

** For error recovery

   Exceptions have been added to most modern languages to handle these
   cases.

** Implementing state machines

   Polymorphism can be used in modern languages to handle these cases.

* The way forward so far

  We've been piling on language features on top of each other.

  And implementing design patterns by hand.

* Case study: computational contexts

** Async

   #+BEGIN_SRC python
     async def foo():
         res1 = await bar()
         res2 = await baz(res1)
         return res2
   #+END_SRC

** Comprehensions

   #+BEGIN_SRC python
     board_indices = [(row_i, col_i)
                      for row_i in range(0, 3)
                      for col_i in range(0, 3)]
   #+END_SRC

** Comprehensions revisited

   What if they looked like this?

   #+BEGIN_SRC python
     list_mode def get_board_indices():
         row_i = list_get range(0, 3)
         col_i = list_get range(0, 3)
         return (row_i, col_i)
   #+END_SRC

   Contrast to

   #+BEGIN_SRC python
     async def foo():
         res1 = await bar()
         res2 = await baz(res1)
         return res2
   #+END_SRC

** Custom contexts

   This was called "overloading the semicolon" by Philip Wadler.

   More and more languages let you do this.
   Async is from a library in F# and not a language feature:

   #+BEGIN_SRC fsharp
     let fetchAndDownload url =
         async {
             let! data = downloadData url

             let processedData = processData data

             return processedData
         }
   #+END_SRC

   =async= is the name of an object here, not a keyword.

** Examples of contexts

   - async
   - optional
   - constraints
   - lists
   - streams


   Scala example

* Case study: embedded languages

** Example 1

   From the *Discord4j* examples

   #+BEGIN_SRC java
     final String token = args[0];
     final DiscordClient client = DiscordClient.create(token);

     client.withGateway(gateway -> {
       final Publisher<?> pingPong = gateway.on(MessageCreateEvent.class, event ->
         Mono.just(event.getMessage())
           .filter(message -> "!ping".equals(message.getContent()))
           .flatMap(Message::getChannel)
           .flatMap(channel -> channel.createMessage("Pong!")));

         final Publisher<?> onDisconnect = gateway.onDisconnect()
           .doOnTerminate(() -> System.out.println("Disconnected!"));

         return Mono.when(pingPong, onDisconnect);
       }).block();
   #+END_SRC

** Example 1 in Kotlin

   Same code in Kotlin (without the disconnect handler)

   #+BEGIN_SRC kotlin
     val token = args[0]
     val client = DiscordClient.create(token)

     client.withGateway {
       mono {
         it.on(MessageCreateEvent::class.java)
           .asFlow()
           .collect {
             val message = it.message
             if (message.content == "!ping") {
               val channel = message.channel.awaitSingle()
               channel.createMessage("Pong!").awaitSingle()
             }
           }
       }
     }
     .block()
   #+END_SRC

** Example 2
** Example in Scala

* Case study: more sophisticated types

** Linearity

** Higher kined types

** Dependent types
