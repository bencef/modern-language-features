#+OPTIONS: toc:nil num:nil ^:nil
#+TITLE: Modern language features
#+AUTHOR: Bence Fábián <begnoc@gmail.com>

* How we used to do programming

  Structured programming:

** Sequences

   #+BEGIN_SRC python
     a = foo()
     b = bar(a)
   #+END_SRC

** Branches

   #+BEGIN_SRC python
     if something():
         foo()
     else:
         bar()
   #+END_SRC

** Loops

   #+BEGIN_SRC python
     while something():
         foo()
   #+END_SRC

* Structured programming

  These can be combined to write most programs

  #+BEGIN_SRC python
    import math

    def get_max(numbers):
        max = -math.inf
        for number in numbers:
            if number > max:
                max = number
        return max
  #+END_SRC

* Structured programming

  =goto= statements still abound in large =C= codebases.

** For error recovery

   Exceptions have been added to most modern languages to handle these
   cases.

** Implementing state machines

   Polymorphism can be used in modern languages to handle these cases.

* The way forward so far

  We've been piling on language features on top of each other.

  And implementing design patterns by hand.

* Case study: computational contexts

** Async

   #+BEGIN_SRC python
     async def foo():
         res1 = await bar()
         res2 = await baz(res1)
         return res2
   #+END_SRC

** Comprehensions

   #+BEGIN_SRC python
     board_indices = [(row_i, col_i)
                      for row_i in range(0, 3)
                      for col_i in range(0, 3)]
   #+END_SRC

** Comprehensions revisited

   What if they looked like this?

   #+BEGIN_SRC python
     list_mode def get_board_indices():
         row_i = list_get range(0, 3)
         col_i = list_get range(0, 3)
         return (row_i, col_i)
   #+END_SRC

   Contrast to

   #+BEGIN_SRC python
     async def foo():
         res1 = await bar()
         res2 = await baz(res1)
         return res2
   #+END_SRC

** Custom contexts

   This was called "overloading the semicolon" by Philip Wadler.

   More and more languages let you do this.
   Async is from a library in F# and not a language feature:

   #+BEGIN_SRC fsharp
     let fetchAndDownload url =
         async {
             let! data = downloadData url

             let processedData = processData data

             return processedData
         }
   #+END_SRC

   =async= is the name of an object here, not a keyword.

** Examples of contexts

   - async
   - optional
   - constraints
   - lists
   - streams


   Scala example

* Case study: embedded languages

** Example 1
** Example 2

* Case study: more sophisticated types

** Linearity

** Higher kined types

* TODO yield?

* TODO pattern matching
